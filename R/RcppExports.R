# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Remove SNPs in hdf5 omic dataset with low data
#'
#' Remove SNPs in hdf5 omic dataset with low data
#' 
#' @param filename, character array indicating the name of the file to create
#' @param group, character array indicating the input group where the data set to be imputed is. 
#' @param dataset, character array indicating the input dataset to be imputed
#' @param outgroup, character array indicating group where the data set will be saved after remove data with if `outgroup` is NULL, output dataset is stored in the same input group. 
#' @param outdataset, character array indicating dataset to store the resulting data after imputation if `outdataset` is NULL, input dataset will be overwritten. 
#' @param pcent, by default pcent = 0.5. Numeric indicating the percentage to be considered to remove SNPs, SNPS with percentage equal or higest will be removed from data
#' @param SNPincols, boolean by default = true, if true, indicates that SNPs are in cols, if SNPincols = false indicates that SNPs are in rows.
#' @return Original hdf5 data file with imputed data
#' @export
bdRemovelowdata <- function(filename, group, dataset, outgroup, outdataset, pcent, SNPincols) {
    .Call(`_BigDataStatMeth_bdRemovelowdata`, filename, group, dataset, outgroup, outdataset, pcent, SNPincols)
}

#' Impute SNPs in hdf5 omic dataset 
#'
#' Impute SNPs in hdf5 omic dataset 
#' 
#' @param filename, character array indicating the name of the file to create
#' @param group, character array indicating the input group where the data set to be imputed is. 
#' @param dataset, character array indicating the input dataset to be imputed
#' @param bycols, boolean by default = true, true indicates that the imputation will be done by columns, otherwise, the imputation will be done by rows
#' @param outgroup, optional character array indicating group where the data set will be saved after imputation if `outgroup` is NULL, output dataset is stored in the same input group. 
#' @param outdataset, optional character array indicating dataset to store the resulting data after imputation if `outdataset` is NULL, input dataset will be overwritten. 
#' @return Original hdf5 data file with imputed data
#' @export
bdImputeSNPHDF5 <- function(filename, group, dataset, outgroup = NULL, outdataset = NULL, bycols = TRUE) {
    .Call(`_BigDataStatMeth_bdImputeSNPHDF5`, filename, group, dataset, outgroup, outdataset, bycols)
}

#' Normalize dataset in hdf5 file
#' 
#' This function normalize data scaling, centering or scaling and centering in a dataset stored in hdf5 file
#' 
#' @param filename string file name where dataset to normalize is stored
#' @param group string or Delayed Array Matrix
#' @param dataset string or Delayed Array Matrix
#' @param bcenter logical (default = TRUE) if TRUE, centering is done by subtracting the column means
#' @param bscale logical (default = TRUE) if TRUE, centering is done by subtracting the column means
#' @param wsize integer (default = 1000), file block size to read to perform normalization
#' @return file with scaled, centered or scaled and centered dataset
#' @examples
#'   a = "See vignette"
#' @export
Normalize_hdf5 <- function(filename, group, dataset, bcenter = NULL, bscale = NULL, wsize = NULL) {
    .Call(`_BigDataStatMeth_Normalize_hdf5`, filename, group, dataset, bcenter, bscale, wsize)
}

#' PCA Descomposition
#' 
#' Compute PCA
#' 
#' @param filename string, file name where dataset is stored 
#' @param group string group name  where dataset is stored in file
#' @param dataset string dataset name with data to perform PCA
#' @param threads integer number of threads used to run PCA
#' @return original file with results in folder PCA/<datasetname>
#' @export
bdPCA_hdf5 <- function(filename, group, dataset, threads) {
    .Call(`_BigDataStatMeth_bdPCA_hdf5`, filename, group, dataset, threads)
}

#' Normalize Delayed Array matrix
#' 
#' This function performs a numerical or Delayed Array matrix normalization
#' 
#' @param x numerical or Delayed Array Matrix
#' @param bcenter logical (default = TRUE) if TRUE, centering is done by subtracting the column means
#' @param bscale logical (default = TRUE) if TRUE, centering is done by subtracting the column means
#' @return numerical matrix
#' @examples
#' library(DelayedArray)
#' 
#' m <- 500
#' n <- 100 
#' x <- matrix(rnorm(m*n), nrow=m, ncol=n)
#' 
#' # with numeric matrix
#' Normalize_Data(x)
#' 
#' # with Delaeyd Array
#' Dx <- DelayedArray(x)
#' 
#' # Center and scale
#' Normalize_Data(Dx)
#' 
#' # Only scale
#' Normalize_Data(Dx, bcenter = FALSE)
#' 
#' # Only center
#' Normalize_Data(Dx, bscale = FALSE)
#' 
#' @export
Normalize_Data <- function(x, bcenter = NULL, bscale = NULL) {
    .Call(`_BigDataStatMeth_Normalize_Data`, x, bcenter, bscale)
}

#' Matrix - Weighted vector Multiplication with numerical or DelayedArray data
#' 
#' This function performs a weighted product of a matrix(X) with a weighted diagonal matrix (w)
#' 
#' @param X numerical or Delayed Array matrix
#' @param W vector with weights
#' @param op string indicating if operation  "Xw" , "wX" or "wXw"
#' @return numerical matrix 
#' @examples
#' 
#' library(DelayedArray)
#' 
#' n <- 100
#' p <- 60
#' 
#' X <- matrix(rnorm(n*p), nrow=n, ncol=p)
#' 
#' u <- runif(n)
#' w <- u * (1 - u)
#' 
#' # by columnes
#' bdwXw(X, w,"wX") 
#' 
#' # with Delayed Array
#' 
#' DX <- DelayedArray(X)
#' 
#' bdwXw(DX, w,"wX")
#' 
#' @export
bdwXw <- function(X, W, op) {
    .Call(`_BigDataStatMeth_bdwXw`, X, W, op)
}

timesTwo <- function(x) {
    .Call(`_BigDataStatMeth_timesTwo`, x)
}

#' Crossproduct and transposed crossproduct of DelayedArray
#' 
#' This function performs a crossproduct or transposed crossproduct of numerical or DelayedArray matrix.
#' 
#' @param a numerical or Delayed Array matrix
#' @param transposed (optional, default = false) boolean indicating if we have to perform a crossproduct (transposed=false) or transposed crossproduct (transposed = true)
#' @return numerical matrix with crossproduct or transposed crossproduct 
#' @examples
#' 
#' library(DelayedArray)
#' 
#' n <- 100
#' p <- 60
#' 
#' X <- matrix(rnorm(n*p), nrow=n, ncol=p)
#' 
#' # without DelayedArray
#' bdcrossprod(X)
#' bdcrossprod(X, transposed = TRUE)
#' 
#' # with DelayedArray
#' XD <- DelayedArray(X)
#' bdcrossprod(XD)
#' bdcrossprod(XD, transposed = TRUE)
#' 
#' @export
bdcrossprod <- function(a, transposed = NULL) {
    .Call(`_BigDataStatMeth_bdcrossprod`, a, transposed)
}

#' Matrix - Weighted vector Multiplication with numerical or DelayedArray data
#' 
#' This function performs a weighted product of a matrix(X) with a weighted diagonal matrix (w)
#' 
#' @param a numerical or Delayed Array matrix
#' @param w vector with weights
#' @param op string indicating if operation 'xtwx' and 'xwxt' for weighted cross product (Matrix - Vector - Matrix) or 'Xw' and 'wX' for weighted product (Matrix - Vector)
#' @return numerical matrix 
#' @examples
#' 
#' library(DelayedArray)
#' 
#' n <- 100
#' p <- 60
#' 
#' X <- matrix(rnorm(n*p), nrow=n, ncol=p)
#' 
#' u <- runif(n)
#' w <- u * (1 - u)
#' ans <- bdwproduct(X, w,"xtwx")
#' 
#' # with Delayed Array
#' 
#' DX <- DelayedArray(X)
#' 
#' ans <- bdwproduct(DX, w,"xtwx")
#' 
#' @export
bdwproduct <- function(a, w, op) {
    .Call(`_BigDataStatMeth_bdwproduct`, a, w, op)
}

#' Matrix - Weighted Scalar Multiplication with numerical or DelayedArray data
#' 
#' This function performs a weighted product of a matrix(X) with a weighted diagonal matrix (w)
#' 
#' @param a numerical or Delayed Array matrix
#' @param w scalar, weight
#' @param op string indicating if operation  "Xw" or "wX"
#' @return numerical matrix 
#' @examples
#' 
#' library(DelayedArray)
#' 
#' n <- 100
#' p <- 60
#' 
#' X <- matrix(rnorm(n*p), nrow=n, ncol=p)
#' w <- 0.75
#' 
#' bdScalarwproduct(X, w,"Xw")
#' bdScalarwproduct(X, w,"wX")
#' 
#' # with Delayed Array
#' 
#' DX <- DelayedArray(X)
#' 
#' bdScalarwproduct(DX, w,"Xw")
#' bdScalarwproduct(DX, w,"wX")
#' 
#' @export
bdScalarwproduct <- function(a, w, op) {
    .Call(`_BigDataStatMeth_bdScalarwproduct`, a, w, op)
}

#' Block matrix multiplication with Delayed Array Object
#' 
#' This function performs a block matrix-matrix multiplication with numeric matrix or Delayed Arrays
#' 
#' @param a a double matrix.
#' @param b a double matrix.
#' @param block_size (optional, defalut = 128) block size to make matrix multiplication, if `block_size = 1` no block size is applied (size 1 = 1 element per block)
#' @param paral, (optional, default = TRUE) if paral = TRUE performs parallel computation else performs seria computation
#' @param threads (optional) only if bparal = true, number of concurrent threads in parallelization if threads is null then threads =  maximum number of threads available
#' @param bigmatrix (optiona, default = 5000) maximum number of rows or columns to consider as big matrix and work with
#' hdf5 files, by default a matrix with more than 5000 rows or files is considered big matrix and computation is made in disk 
#' @param mixblock_size (optiona, default = 128), only if we are working with big matrix and parallel computation = true. 
#' Block size for mixed computation in big matrix parallel. Size of the block to be used to perform parallelized memory 
#' memory of the block read from the disk being processed.
#' @param outfile (optional) file name to work with hdf5 if we are working with big matrix in disk.
#' @return A List with : 
#' \itemize{
#'   \item{"matrix"}{ Result matrix if execution has been performed in memory}
#'   \item{"filename"}{ HDF5 filename if execution has been performed in disk, HDF5 file contains : 
#'     \itemize{
#'       \item{"INPUT"}{hdf5 group with input matrix A and B}
#'       \item{"OUTPUT"}{hdf5 group with output matrix C}
#'     }with input and output matrix.
#'   }
#' }
#' @examples
#' 
#' library(DelayedArray)
#' 
#' # with numeric matrix
#' m <- 500
#' k <- 1500
#' n <- 400
#' A <- matrix(rnorm(n*k), nrow=n, ncol=k)
#' B <- matrix(rnorm(n*k), nrow=k, ncol=n)
#' 
#' blockmult(A,B,128, TRUE)
#' 
#' # with Delaeyd Array
#' AD <- DelayedArray(A)
#' BD <- DelayedArray(B)
#' 
#' blockmult(AD,BD,128, TRUE)
#' @export
blockmult <- function(a, b, block_size = NULL, paral = NULL, threads = NULL, bigmatrix = NULL, mixblock_size = NULL, outfile = NULL, onmemory = NULL) {
    .Call(`_BigDataStatMeth_blockmult`, a, b, block_size, paral, threads, bigmatrix, mixblock_size, outfile, onmemory)
}

CholFactor <- function(a) {
    .Call(`_BigDataStatMeth_CholFactor`, a)
}

CholSolve <- function(a, b) {
    .Call(`_BigDataStatMeth_CholSolve`, a, b)
}

inversechol_par <- function(a, threads = NULL) {
    .Call(`_BigDataStatMeth_inversechol_par`, a, threads)
}

partCrossProd <- function(X) {
    .Call(`_BigDataStatMeth_partCrossProd`, X)
}

partCrossProd_block <- function(X) {
    .Call(`_BigDataStatMeth_partCrossProd_block`, X)
}

parCrossProd <- function(X) {
    .Call(`_BigDataStatMeth_parCrossProd`, X)
}

parCrossProd_block <- function(X) {
    .Call(`_BigDataStatMeth_parCrossProd_block`, X)
}

partCrossProdEigen <- function(X) {
    .Call(`_BigDataStatMeth_partCrossProdEigen`, X)
}

#' Matrix multiplication with Delayed Array Object (RcppParallel)
#' 
#' This function performs a block matrix-matrix multiplication with numeric matrix or Delayed Arrays
#' 
#' @param X double matrix to apply multiplication
#' @param Y double matrix to apply multiplication
#' @param op, (optional, default = "xy"), if op="xy" then performs the x\%*\%y matrix multiplication, if op = "xty" preforms t(X)\%*\% Y, if op = "xyt" performs X\%*\%t(Y)
#' @return numerical matrix
#' @examples
#' 
#' library(DelayedArray)
#' 
#' # with numeric matrix
#' k <- 300
#' n <- 400
#' A <- matrix(rnorm(n*k), nrow=n, ncol=k)
#' B <- matrix(rnorm(k*k), nrow=k)
#' 
#' parXYProd(A,B,"xy")
#' parXYProd(A,B,"xyt")
#' 
#' # with Delaeyd Array
#' AD <- DelayedArray(A)
#' BD <- DelayedArray(B)
#' 
#' parXYProd(AD,BD,"xy")
#' parXYProd(AD,BD,"xyt")
#' 
#' @export
parXYProd <- function(X, Y, op = NULL) {
    .Call(`_BigDataStatMeth_parXYProd`, X, Y, op)
}

#' Block matrix multiplication with Delayed Array Object
#' 
#' This function performs a block matrix-matrix multiplication with numeric matrix or Delayed Arrays
#' 
#' @param X double matrix to apply multiplication
#' @param Y double matrix to apply multiplication
#' @param op, (optional, default = "xy"), if op="xy" then performs the x\%*\%y matrix multiplication, if op = "xty" preforms t(X)\%*\% Y, if op = "xyt" performs X\%*\%t(Y)
#' @return numerical matrix
#' @examples
#' 
#' library(DelayedArray)
#' 
#' # with numeric matrix
#' m <- 500
#' k <- 1500
#' n <- 400
#' A <- matrix(rnorm(n*k), nrow=n, ncol=k)
#' B <- matrix(rnorm(n*k), nrow=k, ncol=n)
#' 
#' parXYProdBlock(A,B,"xy")
#' parXYProdBlock(A,B,"xty")
#' 
#' # with Delaeyd Array
#' AD <- DelayedArray(A)
#' BD <- DelayedArray(B)
#' 
#' parXYProdBlock(AD,BD,"xy")
#' parXYProdBlock(AD,BD,"xty")
#' 
#' 
#' @export
parXYProdBlock <- function(X, Y, op = NULL) {
    .Call(`_BigDataStatMeth_parXYProdBlock`, X, Y, op)
}

parxwxt <- function(X, W) {
    .Call(`_BigDataStatMeth_parxwxt`, X, W)
}

parxtwx <- function(X, W) {
    .Call(`_BigDataStatMeth_parxtwx`, X, W)
}

parXy <- function(X, Y) {
    .Call(`_BigDataStatMeth_parXy`, X, Y)
}

JacobianSVD <- function(X) {
    .Call(`_BigDataStatMeth_JacobianSVD`, X)
}

bdtsvd <- function(X, k = NULL) {
    .Call(`_BigDataStatMeth_bdtsvd`, X, k)
}

bdsvd <- function(X) {
    .Call(`_BigDataStatMeth_bdsvd`, X)
}

#' Pseudo-Inverse
#' 
#' Compute the pseudo-inverse of a singular matrix
#' 
#' @param X Singular matrix (m x n)
#' @return Pseudo-inverse matrix of A
#' @export
bdpseudoinv <- function(X) {
    .Call(`_BigDataStatMeth_bdpseudoinv`, X)
}

#' QR Decomposition 
#' 
#' This function compute QR decomposition (also called a QR factorization) 
#' of a matrix \code{A} into a product \code{A = QR} of an 
#' orthogonal matrix Q and an upper triangular matrix R.
#' 
#' @param X a real square matrix 
#' @param thin boolean thin, if thin = true returns Q thin  decomposition else returns Q full decomposition, default thin = false
#' @return List with orthogonal matrix \code{Q}  and upper triangular matrix \code{R}
#' @export
bdQR <- function(X, thin = NULL) {
    .Call(`_BigDataStatMeth_bdQR`, X, thin)
}

review_decomposition <- function(R, n) {
    .Call(`_BigDataStatMeth_review_decomposition`, R, n)
}

#' Solves matrix equations : A*X = B
#' 
#' 
#' 
#' @param R numerical or Delayed Array matrix. 
#' @param Z numerical or Delayed Array matrix.
#' @param threads integer with number of threads to use with parallelized execution
#' @return X numerical matrix. 
#' @examples
#'  a <- "Unused function"
#' @export
bddtrsm <- function(R, Z, threads = NULL) {
    .Call(`_BigDataStatMeth_bddtrsm`, R, Z, threads)
}

#' Create hdf5 data file and write data to it
#'
#' Creates a hdf5 file with numerical data matrix,
#' 
#' @param filename, character array indicating the name of the file to create
#' @param mat numerical data matrix
#' @param group, character array indicating folder name to put the matrix in hdf5 file
#' @param dataset, character array indicating the dataset name to store the matix data
#' @param transp boolean, if trans=true matrix is stored transposed in hdf5 file
#' @return none
#' @export
Create_HDF5_matrix_file <- function(filename, mat, group = NULL, dataset = NULL, transp = NULL) {
    .Call(`_BigDataStatMeth_Create_HDF5_matrix_file`, filename, mat, group, dataset, transp)
}

#' Write matrix to existing hdf5 file
#'
#' Creates a hdf5 file with numerical data matrix,
#' 
#' @param filename, character array indicating the name of the file to create
#' @param mat numerical data matrix
#' @param group, character array indicating folder or group name to put the matrix in hdf5 file
#' @param dataset, character array indicating the dataset name that contains the matix data
#' @param transp, boolean if true, data is manipulated in transposed form
#' @return none
#' @export
Create_HDF5_matrix <- function(mat, filename, group, dataset, transp = NULL) {
    .Call(`_BigDataStatMeth_Create_HDF5_matrix`, mat, filename, group, dataset, transp)
}

#' Remove element group or dataset from  hdf5 file
#'
#' Remove group or dataset from  hdf5 file
#' 
#' @param filename, character array indicating the name of the file to create
#' @param element path to element, character array indicating the complete route to the element to be removed (folder or dataset). 
#' @return none
#' @export
Remove_HDF5_element <- function(filename, element) {
    .Call(`_BigDataStatMeth_Remove_HDF5_element`, filename, element)
}

#' Inverse Cholesky of Delayed Array
#' 
#' This function get the inverse of a numerical or Delayed Array matrix. If x is hermitian and positive-definite matrix then 
#' performs get the inverse using Cholesky decomposition
#' 
#' 
#' @param x numerical or Delayed Array matrix. If x is Hermitian and positive-definite performs
#' @return inverse matrix of d 
#' @examples
#' 
#' library(DelayedArray)
#' 
#' A <- matrix(c(3,4,3,4,8,6,3,6,9), byrow = TRUE, ncol = 3)
#' bdInvCholesky(A)
#' 
#' # with Delayed Array
#' DA <- DelayedArray(A)
#' bdInvCholesky(DA)
#' 
#' @export
bdInvCholesky <- function(x) {
    .Call(`_BigDataStatMeth_bdInvCholesky`, x)
}

#' k first SVD components for DelayedArray 
#' 
#' This function gets k first components from svd decomposition of numerical or Delayed Array 
#' 
#' @param x numerical or Delayed Array matrix
#' @param k number of eigen values , this should satisfy k = min(n, m) - 1
#' @param nev (optional, default nev = n-1) Number of eigenvalues requested. This should satisfy 1≤ nev ≤ n, where n is the size of matrix. 
#' @param bcenter (optional, defalut = TRUE) . If center is TRUE then centering is done by subtracting the column means (omitting NAs) of x from their corresponding columns, and if center is FALSE, no centering is done.
#' @param bscale (optional, defalut = TRUE) .  If scale is TRUE then scaling is done by dividing the (centered) columns of x by their standard deviations if center is TRUE, and the root mean square otherwise. If scale is FALSE, no scaling is done.
#' @return u eigenvectors of AA^t, mxn and column orthogonal matrix
#' @return v eigenvectors of A^tA, nxn orthogonal matrix
#' @return d singular values, nxn diagonal matrix (non-negative real values)
#' @examples
#' 
#' library(DelayedArray)
#' 
#' n <- 500
#' A <- matrix(rnorm(n*n), nrow=n, ncol=n)
#' AD <- DelayedArray(A)
#' 
#' # svd without normalization
#' decsvd <- bdSVD( A, bscale = FALSE, bcenter = FALSE ) # No matrix normalization
#' decsvd$d
#' decsvd$u
#' 
#' # svd with normalization
#' decvsd <- bdSVD( A, bscale = TRUE, bcenter = TRUE) # Matrix normalization
#' 
#' decsvd$d
#' decsvd$u
#' 
#' # svd with scaled matrix (sd)
#' decvsd <- bdSVD( A, bscale = TRUE, bcenter = FALSE) # Scaled matrix
#' 
#' decsvd$d
#' decsvd$u
#' # svd with centered matrix (sd)
#' decvsd <- bdSVD( A, bscale = FALSE, bcenter = TRUE) # Centered matrix
#' decsvd$d
#' decsvd$u
#' 
#' @export
bdSVD <- function(x, k = 0L, nev = 0L, bcenter = TRUE, bscale = TRUE) {
    .Call(`_BigDataStatMeth_bdSVD`, x, k, nev, bcenter, bscale)
}

#' Block SVD decomposition using an incremental algorithm.
#'
#' Singular values and left singular vectors of a real nxp matrix 
#' @title Block SVD decomposition using an incremental algorithm.
#' @param x a real nxp matrix in hdf5 file
#' @param group group in hdf5 data file where dataset is located
#' @param dataset matrix dataset with data to perform SVD
#' @param k number of local SVDs to concatenate at each level 
#' @param q number of levels
#' @param bcenter (optional, defalut = TRUE) . If center is TRUE then centering is done by subtracting the column means (omitting NAs) of x from their corresponding columns, and if center is FALSE, no centering is done.
#' @param bscale (optional, defalut = TRUE) .  If scale is TRUE then scaling is done by dividing the (centered) columns of x by their standard deviations if center is TRUE, and the root mean square otherwise. If scale is FALSE, no scaling is done.
#' @param threads (optional) only used in some operations inside function. If threads is null then threads =  maximum number of threads available - 1.
#' @return a list of three components with the singular values and left and right singular vectors of the matrix
#' @return A List with : 
#' \itemize{
#'   \item{"u"}{ eigenvectors of AA^t, mxn and column orthogonal matrix }
#'   \item{"v"}{ eigenvectors of A^tA, nxn orthogonal matrix }
#'   \item{"v"}{ singular values, nxn diagonal matrix (non-negative real values) }
#' }
#' @export
bdSVD_hdf5 <- function(x, group = NULL, dataset = NULL, k = 2L, q = 1L, bcenter = TRUE, bscale = TRUE, threads = NULL) {
    .Call(`_BigDataStatMeth_bdSVD_hdf5`, x, group, dataset, k, q, bcenter, bscale, threads)
}

#' Complete SVD with Lapack Functions for DelayedArray and RObjects
#' 
#' This function performs a complete svd decomposition of numerical matrix or Delayed Array with 
#' 
#' @param x numerical or Delayed Array matrix
#' @param bcenter (optional, defalut = TRUE) . If center is TRUE then centering is done by subtracting the column means (omitting NAs) of x from their corresponding columns, and if center is FALSE, no centering is done.
#' @param bscale (optional, defalut = TRUE) .  If scale is TRUE then scaling is done by dividing the (centered) columns of x by their standard deviations if center is TRUE, and the root mean square otherwise. If scale is FALSE, no scaling is done.
#' @return u eigenvectors of AA^t, mxn and column orthogonal matrix
#' @return v eigenvectors of A^tA, nxn orthogonal matrix
#' @return d singular values, nxn diagonal matrix (non-negative real values)
#' @examples
#' 
#' library(DelayedArray)
#' 
#' n <- 500
#' A <- matrix(rnorm(n*n), nrow=n, ncol=n)
#' AD <- DelayedArray(A)
#' 
#' # svd without normalization
#' decsvd <- bdSVD_lapack( A, bscale = FALSE, bcenter = FALSE ) # No matrix normalization
#' decsvd$d
#' decsvd$u
#' 
#' # svd with normalization
#' decvsd <- bdSVD_lapack( A, bscale = TRUE, bcenter = TRUE) # Matrix normalization
#' decvsd <- bdSVD_lapack( A ) # Matrix normalization too
#' decsvd$d
#' decsvd$u
#' 
#' # svd with scaled matrix (sd)
#' decvsd <- bdSVD_lapack( A, bscale = TRUE, bcenter = FALSE) # Scaled matrix
#' 
#' decsvd$d
#' decsvd$u
#' # svd with centered matrix (sd)
#' decvsd <- bdSVD_lapack( A, bscale = FALSE, bcenter = TRUE) # Centered matrix
#' decsvd$d
#' decsvd$u
#' 
#' @export
bdSVD_lapack <- function(x, bcenter = TRUE, bscale = TRUE) {
    .Call(`_BigDataStatMeth_bdSVD_lapack`, x, bcenter, bscale)
}

