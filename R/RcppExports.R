# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Block SVD decomposition for hdf5 files using an incremental algorithm.
#'
#' Singular values and left singular vectors of a real nxp matrix 
#' Block SVD decomposition using an incremental algorithm.
#' @param file a real nxp matrix in hdf5 file
#' @param group group in hdf5 data file where dataset is located
#' @param dataset matrix dataset with data to perform SVD
#' @param k number of local SVDs to concatenate at each level 
#' @param q number of levels
#' @param bcenter (optional, defalut = TRUE) . If center is TRUE then centering is done by subtracting the column means (omitting NAs) of x from their corresponding columns, and if center is FALSE, no centering is done.
#' @param bscale (optional, defalut = TRUE) .  If scale is TRUE then scaling is done by dividing the (centered) columns of x by their standard deviations if center is TRUE, and the root mean square otherwise. If scale is FALSE, no scaling is done.
#' @param rankthreshold double, threshold used to determine the range of the array. The matrix rank is equal to the number of
#'  singular values different from the threshold. By default, threshold = 0 is used to get the matrix rank , but it can be
#'  changed to an approximation of 0.
#' @param threads (optional) only used in some operations inside function. If threads is null then threads =  maximum number of threads available - 1.
#' @return a list of three components with the singular values and left and right singular vectors of the matrix
#' @return A List with : 
#' \itemize{
#'   \item{"u"}{ eigenvectors of AA^t, mxn and column orthogonal matrix }
#'   \item{"v"}{ eigenvectors of A^tA, nxn orthogonal matrix }
#'   \item{"v"}{ singular values, nxn diagonal matrix (non-negative real values) }
#' }
#' @export
bdSVD_hdf5 <- function(file, group = NULL, dataset = NULL, k = 2L, q = 1L, bcenter = TRUE, bscale = TRUE, rankthreshold = 0.0, force = NULL, threads = NULL) {
    .Call('_BigDataStatMeth_bdSVD_hdf5', PACKAGE = 'BigDataStatMeth', file, group, dataset, k, q, bcenter, bscale, rankthreshold, force, threads)
}

#' Crossprod with hdf5 matrix
#' 
#' This function performs the crossprod from a matrix inside and hdf5 data file
#' 
#' @param filename string file name where dataset to normalize is stored
#' @param group, string, group name where dataset A is stored
#' @param A string name inside HDF5 file
#' @param groupB, string, group name where dataset b is stored
#' @param B string, dataset name for matrix B inside HDF5 file
#' @param block_size (optional, defalut = 128) block size to make matrix multiplication, if `block_size = 1` no block size is applied (size 1 = 1 element per block)
#' @param paral, (optional, default = TRUE) if paral = TRUE performs parallel computation else performs seria computation
#' @param threads (optional) only if bparal = true, number of concurrent threads in parallelization if threads is null then threads =  maximum number of threads available
#' @param mixblock_size (optional) only for debug pourpose
#' @param outgroup (optional) group name to store results from Crossprod inside hdf5 data file
#' @return no value
#' @examples
#'   
#'   library(BigDataStatMeth)
#'   library(rhdf5)
#'      
#'   matA <- matrix(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15), nrow = 3, byrow = TRUE)
#'   matB <- matrix(c(15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,5,3,4,5,2,6,2,3,4,
#'                    42, 23, 23, 423,1,2), nrow = 3, byrow = TRUE)
#'   
#'   bdCreate_hdf5_matrix_file("BasicMatVect.hdf5", matA, "INPUT", "matA")
#'   bdAdd_hdf5_matrix(matB, "BasicMatVect.hdf5", "INPUT", "matB")
#'   
#'   res <- bdCrossprod_hdf5("BasicMatVect.hdf5", "INPUT","matA", block_size = 3)
#'   res2 <- bdCrossprod_hdf5("BasicMatVect.hdf5", "INPUT",
#'                            "matA", "INPUT","matB", block_size = 3)
#'   
#'   # Examine hierarchy before open file
#'   h5ls("BasicMatVect.hdf5")
#'   
#'   # Open file
#'   h5fdelay = H5Fopen("BasicMatVect.hdf5")
#'   
#'   # Show hdf5 hierarchy (groups)
#'   h5fdelay
#'   
#'   res <- h5fdelay$OUTPUT$CrossProd_matAxmatA
#'   res2 <- h5fdelay$OUTPUT$CrossProd_matAxmatB
#'   
#'   all.equal(crossprod(matA), res)
#'   all.equal(crossprod(matA,matB), res2)
#'   
#'   # Close hdf5 data file
#'   H5Fclose(h5fdelay)
#'   
#'   # Remove file (used as example)
#'   if (file.exists("BasicMatVect.hdf5")) {
#'     # Delete file if it exist
#'     file.remove("BasicMatVect.hdf5")
#'   }
#'   
#' 
#' @export
bdCrossprod_hdf5 <- function(filename, group, A, B = NULL, groupB = NULL, block_size = NULL, mixblock_size = NULL, paral = NULL, threads = NULL, outgroup = NULL, outdataset = NULL, force = NULL) {
    invisible(.Call('_BigDataStatMeth_bdCrossprod_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, A, B, groupB, block_size, mixblock_size, paral, threads, outgroup, outdataset, force))
}

#' Normalize dataset in hdf5 file
#' 
#' This function normalize data scaling, centering or scaling and centering 
#' in a dataset stored in hdf5 file
#' 
#' @param filename string file name where dataset to normalize is stored
#' @param group string Matrix
#' @param dataset string Matrix
#' @param bcenter logical (default = TRUE) if TRUE, centering is done by 
#' subtracting the column means
#' @param bscale logical (default = TRUE) if TRUE, centering is done by 
#' subtracting the column means
#' @param byrows logical (default = FALSE) if TRUE, centering is done by 
#' subtracting the rows means, util when working with hdf5 datasets stored 
#' in Row Major format.
#' @param wsize integer (default = 1000), file block size to read to 
#' perform normalization
#' @param force, boolean if true, previous results in same location inside 
#' hdf5 will be overwritten.
#' @return file with scaled, centered or scaled and centered dataset
#' @examples
#'   a = "See vignette"
#' @export
bdNormalize_hdf5 <- function(filename, group, dataset, bcenter = NULL, bscale = NULL, byrows = NULL, wsize = NULL, force = FALSE) {
    invisible(.Call('_BigDataStatMeth_bdNormalize_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, dataset, bcenter, bscale, byrows, wsize, force))
}

#' Hdf5 datasets multiplication
#'
#' Multiplies two existing datasets in hdf5 datafile and stores results i a new hdf5 dataset.
#' 
#' @export
bdblockmult_hdf5 <- function(filename, group, A, B, groupB = NULL, block_size = NULL, mixblock_size = NULL, paral = NULL, threads = NULL, outgroup = NULL, outdataset = NULL, force = NULL) {
    invisible(.Call('_BigDataStatMeth_bdblockmult_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, A, B, groupB, block_size, mixblock_size, paral, threads, outgroup, outdataset, force))
}

#' Block matrix multiplication
#' 
#' This function performs a block matrix-matrix multiplication with numeric matrix
#' 
#' @param filename string file name where dataset to normalize is stored
#' @param group string path inside hdf5 data file where matrix A is stored
#' @param A, string with dataset name where matrix is stored
#' @param B, string with dataset name where matrix is stored
#' @param groupB string path inside hdf5 data file where matrix B is stored
#' @param block_size integer, block size used to perform calculus
#' @param mixblock_size integer
#' @param outgroup string with the group name under the matrix will be stored
#' @param outdataset string with the dataset name to store results
#' @param force, boolean
#' 
#' @return list with filename and the group and dataset name under the results are stored
#' @examples
#' 
#' library(Matrix)
#' library(BigDataStatMeth)
#' 
#' k <- 1e3
#' set.seed(1)
#' x_sparse <- sparseMatrix(
#'     i = sample(x = k, size = k),
#'     j = sample(x = k, size = k),
#'     x = rnorm(n = k)
#' )
#' set.seed(2)
#' y_sparse <- sparseMatrix(
#'     i = sample(x = k, size = k),
#'     j = sample(x = k, size = k),
#'     x = rnorm(n = k)
#' )
#' 
#' if( isTRUE(file.exists('BasicMatVect.hdf5'))) {
#'      file.remove('BasicMatVect.hdf5')
#' }
#' bdCreate_hdf5_matrix_file("BasicMatVect.hdf5", as.matrix(x_sparse), "SPARSE", "x_sparse")
#' bdAdd_hdf5_matrix(as.matrix(y_sparse), "BasicMatVect.hdf5", "SPARSE", "y_sparse")
#' 
#' d <- bdblockmult_sparse_hdf5("BasicMatVect.hdf5", "SPARSE", "x_sparse", "y_sparse")
#' 
#' # Remove file (used as example)
#' if (file.exists("BasicMatVect.hdf5")) {
#'   # Delete file if it exist
#'   file.remove("BasicMatVect.hdf5")
#' }
#' 
#' @export
bdblockmult_sparse_hdf5 <- function(filename, group, A, B, groupB = NULL, block_size = NULL, mixblock_size = NULL, paral = NULL, threads = NULL, outgroup = NULL, outdataset = NULL, force = NULL) {
    invisible(.Call('_BigDataStatMeth_bdblockmult_sparse_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, A, B, groupB, block_size, mixblock_size, paral, threads, outgroup, outdataset, force))
}

#' Hdf5 datasets substract
#'
#' Substracts two existing datasets in hdf5 datafile and stores results i a new hdf5 dataset.
#' 
#' @export
bdblockSubstract_hdf5 <- function(filename, group, A, B, groupB = NULL, block_size = NULL, paral = NULL, threads = NULL, outgroup = NULL, outdataset = NULL, force = NULL) {
    invisible(.Call('_BigDataStatMeth_bdblockSubstract_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, A, B, groupB, block_size, paral, threads, outgroup, outdataset, force))
}

#' Hdf5 datasets sum
#'
#' Sum two existing datasets in hdf5 datafile and stores results i a new hdf5 dataset.
#' 
#' @export
bdblockSum_hdf5 <- function(filename, group, A, B, groupB = NULL, block_size = NULL, paral = NULL, threads = NULL, outgroup = NULL, outdataset = NULL, force = NULL) {
    invisible(.Call('_BigDataStatMeth_bdblockSum_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, A, B, groupB, block_size, paral, threads, outgroup, outdataset, force))
}

#' tCrossprod with hdf5 matrix
#' 
#' This function performs the tcrossprod from a matrix inside and hdf5 data file
#' 
#' @param filename string file name where dataset to normalize is stored
#' @param group, string, group name where dataset A is stored
#' @param A string name inside HDF5 file
#' @param groupB, string, group name where dataset b is stored
#' @param B string, dataset name for matrix B inside HDF5 file
#' @param block_size (optional, defalut = 128) block size to make matrix multiplication, if `block_size = 1` no block size is applied (size 1 = 1 element per block)
#' @param paral, (optional, default = TRUE) if paral = TRUE performs parallel computation else performs seria computation
#' @param threads (optional) only if bparal = true, number of concurrent threads in parallelization if threads is null then threads =  maximum number of threads available
#' @param mixblock_size (optional) only for debug pourpose
#' @param outgroup (optional) group name to store results from tCrossprod inside hdf5 data file
#' @return no value
#' @examples
#'   
#'   library(BigDataStatMeth)
#'   library(rhdf5)
#'      
#'   matA <- matrix(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15), nrow = 3, byrow = TRUE)
#'   matB <- matrix(c(15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,5,3,4,5,2,6,2,3,4,
#'                    42, 23, 23, 423,1,2), nrow = 3, byrow = TRUE)
#'   
#'   bdCreate_hdf5_matrix_file("BasicMatVect.hdf5", matA, "INPUT", "matA")
#'   bdAdd_hdf5_matrix(matB, "BasicMatVect.hdf5", "INPUT", "matB")
#'   
#'   res <- bdtCrossprod_hdf5("BasicMatVect.hdf5", "INPUT","matA", block_size = 3)
#'   res2 <- bdtCrossprod_hdf5("BasicMatVect.hdf5", "INPUT",
#'                            "matA", "INPUT","matB", block_size = 3)
#'   
#'   # Examine hierarchy before open file
#'   h5ls("BasicMatVect.hdf5")
#'   
#'   # Open file
#'   h5fdelay = H5Fopen("BasicMatVect.hdf5")
#'   
#'   # Show hdf5 hierarchy (groups)
#'   h5fdelay
#'   
#'   res <- h5fdelay$OUTPUT$tCrossProd_matAxmatA
#'   res2 <- h5fdelay$OUTPUT$tCrossProd_matAxmatB
#'   
#'   all.equal(tcrossprod(matA), res)
#'   all.equal(tcrossprod(matA,matB), res2)
#'   
#'   # Close hdf5 data file
#'   H5Fclose(h5fdelay)
#'   
#'   # Remove file (used as example)
#'   if (file.exists("BasicMatVect.hdf5")) {
#'     # Delete file if it exist
#'     file.remove("BasicMatVect.hdf5")
#'   }
#'   
#' 
#' @export
bdtCrossprod_hdf5 <- function(filename, group, A, B = NULL, groupB = NULL, block_size = NULL, mixblock_size = NULL, paral = NULL, threads = NULL, outgroup = NULL, outdataset = NULL, force = NULL) {
    invisible(.Call('_BigDataStatMeth_bdtCrossprod_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, A, B, groupB, block_size, mixblock_size, paral, threads, outgroup, outdataset, force))
}

#' Get diagonal matrix
#'
#' Gry diagonal matrix from an existing dataset inside hdf5
#'
#' @param filename, character array with the name of an existin hdf5 data file containing the dataset to be modified
#' @param group, character array indicating the input group where dataset is stored
#' @param dataset, character array indicating the input dataset name
#' @return Numeric vector with all diagonal elements from hdf5 dataset
#' @examples
#' 
#' library(BigDataStatMeth)
#' library(rhdf5)
#' 
#' X <- matrix(rnorm(100), 10, 10)
#' diag(X) <- 0.5
#' # Create hdf5 data file with  data (Y)
#' bdCreate_hdf5_matrix_file("test_file2.hdf5", X, "data", "X", force = TRUE)
#' # Update diagonal
#' diagonal <- bdgetDiagonal_hdf5("test_file.hdf5", "data", "X")
#' 
#' @export
bdgetDiagonal_hdf5 <- function(filename, group, dataset) {
    .Call('_BigDataStatMeth_bdgetDiagonal_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, dataset)
}

#' Write diagonal matrix
#'
#' Write diagonal matrix to an existing dataset inside hdf5
#'
#' @param diagonal, numeric vector with diagonal elements to be written in existing dataset. 
#' @param filename, character array with the name of an existin hdf5 data file containing the dataset to be modified
#' @param group, character array indicating the input group where the data set to be modified. 
#' @param dataset, character array indicating the input dataset to be modified
#' @return Original hdf5 dataset with new diagonal elements
#' @examples
#' library(BigDataStatMeth)
#' library(rhdf5)
#' 
#' # Prepare data and functions
#' X <- matrix(rnorm(100), 10, 10)
#' diagonal <- c(1,2,3,4,5,6,7, 8, 9, 10)
#' 
#' # Create hdf5 data file with  data (Y)
#' bdCreate_hdf5_matrix_file("test_file.hdf5", X, "data", "X", force = TRUE)
#' 
#' # Update diagonal
#' bdWriteDiagonal_hdf5(diagonal, "test_file.hdf5", "data", "X")
#' 
#' @export
bdWriteDiagonal_hdf5 <- function(diagonal, filename, group, dataset) {
    invisible(.Call('_BigDataStatMeth_bdWriteDiagonal_hdf5', PACKAGE = 'BigDataStatMeth', diagonal, filename, group, dataset))
}

#' Get sd and Mean by Rows or Columns
#' 
#' This functions gets Standard Deviation (sd) or Mean by Rows or Columns and
#' store results in hdf5 dataset inside the file
#' 
#' @param filename string file name where dataset to normalize is stored
#' @param group string Matrix
#' @param dataset string Matrix
#' @param sd logical (default = TRUE) if TRUE, standard deviation is computed
#' @param mean logical (default = TRUE) if TRUE, mean is computed 
#' @param byrows logical (default = FALSE) if TRUE, sd and mean are computed
#' by columns, if byrows=TRUE then sd and mean are computed by Rows.
#' @param wsize integer (default = 1000), file block size to read to 
#' perform calculus exitexit
#' @param force, boolean if true, previous results in same location inside 
#' hdf5 will be overwritten.
#' @return hdf5 data file containing two new datasets, one for sd (if sd is 
#' requested) and another for the mean (if mean is requested). Results are
#' stored inside a folder mean_sd inside hdf5 data file with names: 
#' sd.<dataset>, mean.<dataset> respectively
#' @examples
#' 
#' library(BigDataStatMeth)
#'     
#' # Prepare data and functions
#' set.seed(123)
#' Y <- matrix(rnorm(100), 10, 10)
#' X <- matrix(rnorm(10), 10, 1)
#'     
#' # Create hdf5 data file with  data (Y)
#' bdCreate_hdf5_matrix_file("test.hdf5", Y, "data", "Y", force = TRUE)
#' bdAdd_hdf5_matrix( X, "test.hdf5",  "data", "X", force = TRUE)
#' 
#' # Get mean and sd        
#' bdgetSDandMean_hdf5(filename = "test.hdf5", group = "data", dataset = "Y",
#'                     sd = TRUE, mean = TRUE,byrows = TRUE)
#'         
#' @export
bdgetSDandMean_hdf5 <- function(filename, group, dataset, sd = NULL, mean = NULL, byrows = NULL, wsize = NULL, force = FALSE) {
    invisible(.Call('_BigDataStatMeth_bdgetSDandMean_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, dataset, sd, mean, byrows, wsize, force))
}

#' Write Upper/Lower triangular matrix
#'
#' Write diagonal matrix to an existing dataset inside hdf5
#'
#' @param filename, character array with the name of an existin hdf5 data file containing the dataset to be modified
#' @param group, character array indicating the input group where the data set to be modified. 
#' @param dataset, character array indicating the input dataset to be modified
#' @param copytolower, boolean with default value = false. If true, sets lower 
#' triangular matrix using upper triangular matrix, if lower=false (default 
#' value) sets upper triangular matrix using lower triangular matrix.
#' @param elementsBlock, optional integer defines de maximum number of elements 
#' to read from hdf5 data file in each block. By default this value is set 
#' to 10000. If matrix is bigger thant 5000x5000 then block is set to number 
#' of rows or columns x 2
#' @examples
#' library(BigDataStatMeth)
#' 
#' # Prepare data and functions
#' X <- matrix(rnorm(100), 10, 10)
#' X.1 <- X
#' X[lower.tri(X)] <- 0
#' # Create hdf5 data file with  data (Y)
#' bdCreate_hdf5_matrix_file("test_file.hdf5", X, "data", "X", force = TRUE)
#' # Update Lower triangular matrix in hdf5
#' bdWriteOppsiteTriangularMatrix_hdf5(filename = "test_file.hdf5", 
#'         group = "data", dataset = "X", copytolower = TRUE, elementsBlock = 10)
#' 
#' X <- X.1
#' X[upper.tri(X)] <- 0
#' # CAdd matrix data to a file
#' bdAdd_hdf5_matrix(X, "test_file.hdf5", "data", "Y", force = TRUE)
#' # Update Upper triangular matrix in hdf5
#' bdWriteOppsiteTriangularMatrix_hdf5(filename = "test_file.hdf5", 
#'         group = "data", dataset = "Y", copytolower = FALSE, elementsBlock = 10)
#' 
#' @export
bdWriteOppsiteTriangularMatrix_hdf5 <- function(filename, group, dataset, copytolower = NULL, elementsBlock = 1000000L) {
    invisible(.Call('_BigDataStatMeth_bdWriteOppsiteTriangularMatrix_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, dataset, copytolower, elementsBlock))
}

#' Apply vector calculus to a dataset in hdf5 file
#' 
#' This function applies a calculus with a vector to a matrix. Multiplies, 
#' sums, substract or divide each matrix row/column from a hdf5 dataset 
#' using a vector
#' 
#' @param filename string file name where dataset to apply weights is located
#' @param group string with the path inside the hdf5 data file where matrix 
#' is located
#' @param dataset string with the matrix name
#' @param vectorgroup string with the path inside the hdf5 data file where 
#' vector is located
#' @param vectordataset string with the vector name
#' @param outdataset character array with output dataset name where we want to 
#' store results
#' @param outgroup optional, character array with output group name where we 
#' want to store results if not provided then results are stored in the same 
#' group as original dataset
#' @param func, Character array, function to be applyed : 
#'"+" : to sum a vector to a matrix dataset by columns or rows
#'"-" : to substract a vector to a matrix dataset by columns or rows
#'"*" : to multiply a vector to a matrix dataset by columns or rows
#'"/" : to divide a vector to a matrix dataset by columns or rows
#' @param byrows logical (default = FALSE). By default weights are applied by 
#' columns but if byrows=TRUE then weights are applied by rows 
#' @param paral, (optional, default = TRUE) if paral = TRUE performs parallel 
#' computation else performs seria computation
#' @param threads (optional) only if bparal = true, number of concurrent 
#' threads in parallelization if threads is null then threads =  maximum 
#' number of threads available
#' @param force, boolean if true, previous results in same location inside 
#' hdf5 will be overwritten.
#' @return file with weighted dataset
#' @examples
#'library(BigDataStatMeth)
#'    
#'# Prepare data and functions
#'set.seed(123)
#'Y <- matrix(rnorm(100), 10, 10)
#'X <- matrix(rnorm(10), 10, 1)
#'        
#'# Create hdf5 data file with  data (Y)
#'bdCreate_hdf5_matrix_file("test.hdf5", Y, "data", "Y", force = TRUE)
#'bdAdd_hdf5_matrix( X, "test.hdf5",  "data", "X", force = TRUE)
#'            
#'bdcomputeMatrixVector_hdf5("test.hdf5", 
#'                           group = "data", dataset = "Y",
#'                           vectorgroup = "data", vectordataset = "X", 
#'                           outdataset = "ProdComputed", 
#'                           func = "*",
#'                           byrows = TRUE, force = TRUE)
#'    
#'bdcomputeMatrixVector_hdf5("test.hdf5", 
#'                           group = "data", dataset = "Y",
#'                           vectorgroup = "data", vectordataset = "X", 
#'                           outdataset = "SumComputed", 
#'                           func = "-",
#'                           byrows = TRUE, force = TRUE)
#'    
#'bdcomputeMatrixVector_hdf5("test.hdf5", 
#'                           group = "data", dataset = "Y",
#'                           vectorgroup = "data", vectordataset = "X", 
#'                           outdataset = "SubsComputed", 
#'                           func = "-",
#'                           byrows = FALSE, force = TRUE)
#' @export
bdcomputeMatrixVector_hdf5 <- function(filename, group, dataset, vectorgroup, vectordataset, outdataset, func, outgroup = NULL, byrows = NULL, paral = NULL, threads = NULL, force = FALSE) {
    invisible(.Call('_BigDataStatMeth_bdcomputeMatrixVector_hdf5', PACKAGE = 'BigDataStatMeth', filename, group, dataset, vectorgroup, vectordataset, outdataset, func, outgroup, byrows, paral, threads, force))
}

#' Create hdf5 data file and write data to it
#'
#' Creates a hdf5 file with numerical data matrix,
#' 
#' @param filename, character array indicating the name of the file to create
#' @param object numerical data matrix
#' @param group, character array indicating folder name to put the matrix in hdf5 file
#' @param dataset, character array indicating the dataset name to store the matix data
#' @param transp boolean, if trans=true matrix is stored transposed in hdf5 file
#' @param overwriteFile, optional boolean by default overwriteFile = false, if true and file exists, removes old file and creates a new file with de dataset data.
#' @param overwriteDataset, optional boolean by default overwriteDataset = false,  if true and dataset exists, removes old dataset and creates a new dataset.
#' @param unlimited, optional boolean by default unlimited = false, if true creates a dataset that can growth.
#' @return none
#' 
#' @examples
#' 
#' matA <- matrix(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15), nrow = 3, byrow = TRUE)
#' bdCreate_hdf5_matrix(filename = "test_temp.hdf5", 
#'                     object = a, group = "datasets", 
#'                     dataset = "datasetA", transp = FALSE, 
#'                     overwriteFile = TRUE, 
#'                     overwriteDataset = TRUE,
#'                     unlimited = FALSE,)
#' 
#' # Remove file (used as example)
#'   if (file.exists("test_temp.hdf5")) {
#'     # Delete file if it exist
#'     file.remove("test_temp.hdf5")
#'   }
#' 
#' @export
bdCreate_hdf5_matrix <- function(filename, object, group = NULL, dataset = NULL, transp = NULL, overwriteFile = NULL, overwriteDataset = NULL, unlimited = NULL) {
    invisible(.Call('_BigDataStatMeth_bdCreate_hdf5_matrix', PACKAGE = 'BigDataStatMeth', filename, object, group, dataset, transp, overwriteFile, overwriteDataset, unlimited))
}

